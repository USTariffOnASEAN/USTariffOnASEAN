<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Dashboard with 3D Maps + 3D Bars + Dumbbell (Scrollable)</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

  <!-- Mapbox GL JS CSS -->
  <link
    href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css"
    rel="stylesheet"
  />

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

  <!-- Plotly for 3D Bar Chart -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <!-- Highcharts + Modules for Dumbbell Chart -->
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script src="https://code.highcharts.com/highcharts-more.js"></script>
  <script src="https://code.highcharts.com/modules/dumbbell.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /*─────────────────────────────────────────────────────────────────*/
    /* Allow scrolling on the page (instead of hiding overflow)       */
    html, body {
      margin: 0;
      padding: 0;
      height: auto;
      overflow: auto;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
      min-height: calc(180vh + 90px);
    }

    /*─────────────────────────────────────────────────────────────────*/
    /* Make the filters “float” at the top of the window, above the maps */
    #scenarioSelector,
    #countrySelector,
    #sectorSelector {
      position: fixed;
      top: 30px;
      z-index: 1000;
      background: white;
      padding: 6px 10px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      outline: none;
    }

    #scenarioSelector {
      left: 2%;
    }
    #countrySelector {
      left: calc(2% + 165px);
    }
    #sectorSelector {
      left: calc(2% + 305px);
    }

    
    #tradeLossCard {
      background: #ffffff;
      padding: 15px 20px;
      border-radius: 10px;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
      min-width: 200px;
    }

    #tradeLossCard h4 {
      margin: 0;
      font-size: 14px;
      color: #555;
    }

    #tradeLossCard p {
      margin: 5px 0 0;
      font-size: 22px;
      font-weight: bold;
      color: #e63946;
    }


        /*─────────────────────────────────────────────────────────────────*/
    /* Dumbbell chart under the 3D Bar charts                          */
    .chart-box.left-under2 {
     top: 90px;/*calc(360px + 45% + 10px + 45% + 10px);*/
      left: 2%;
      width: 96.2%;
      height: 60%;
    }

    /*─────────────────────────────────────────────────────────────────*/
    /* Shared “card” style for map‐boxes and chart‐boxes               */
    .map-box,
    .chart-box {
      position: absolute;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      box-sizing: border-box;
      overflow: hidden;
    }

    /*─────────────────────────────────────────────────────────────────*/
    /* Left map: 50px down, 2% left, 47.2% width, 45% height          */
    .map-box.left {
      top: calc(90px + 60% + 10px); 
      left: 2%;
      width: 47.2%;
      height: 45%;
    }

    /*─────────────────────────────────────────────────────────────────*/
    /* Right map: 50px down, 51% left, 47.2% width, 45% height        */
    .map-box.right {
      top: calc(90px + 60% + 10px); 
      left: 51%;
      width: 47.2%;
      height: 45%;
    }

    /*─────────────────────────────────────────────────────────────────*/
    /* 3D Bar chart UNDER the LEFT map (PRIMARY)                       */
    /* These are the exact same properties your original .left-under had,
       except we kept the same top/left/width/height/overflow values.  */
    .chart-box.left-under {
      top: calc(340px + 60% + 200px); /* 50px + 45% map height + 10px gap */
      left: 2%;
      width: 47.2%;
      height: 50%;
      overflow: visible;
    }

    /*─────────────────────────────────────────────────────────────────*/
    /* 3D Bar chart UNDER the RIGHT map (ESTIMATED)                    */
    /* This is exactly your original left-under CSS, but moved to 51%. */
    .chart-box.right-under {
      top: calc(340px + 60% + 200px); /* same vertical offset as left-under */
      left: 51%;
      width: 47.2%;
      height: 50%;
      overflow: visible;
    }

    /* Trade Loss Card Styles */
#tradeLossCard {
  position:absolute ;
  top: 10px;
  left: 600px;
  z-index: 1000;
  background: #ffffff;
  padding: 15px 20px;
  border: 1px solid #ccc;
  border-radius: 10px;
  box-shadow: 0 3px 8px rgba(0, 0, 0, 0.1);
  min-width: 100px;
  display: block; /* Ensure it's visible */
}

#tradeLossCard h4 {
  margin: 0;
  font-size: 12px;
  color: #555;
}

#tradeLossCard p {
  margin: 2px 0 0;
  font-size: 16px;
  font-weight: bold;
  color: #e63946;
}
/* Treemap container styles */
.chart-box.treemap-container,
.chart-box.treemap-container-right{
  top: calc(90px + 60% + 10px + 45% + 10px + 50% + 10px);
  left: 2%;
  width: 47.2%;
  height: 45%;
   overflow: hidden; 
}

/* D3 Treemap specific styles */
#treemapChart {
  width: 100%;
  height: 100%;
  font-family: Arial, sans-serif;
  position: relative; 
}

.treemap-rect {
  stroke: #fff;
  stroke-width: 1px; 
}
/* Second Treemap container styles */
.chart-box.treemap-container-right {
  top: calc(90px + 60% + 10px + 45% + 10px + 50% + 10px);
  left: 51%;
  width: 47.2%;
  height: 45%;
}

/* Improved Treemap text styles */
.treemap-text {
  font-size: 10px;
  fill: #333;
  text-anchor: middle;
  pointer-events: none;
}

.treemap-text tspan {
  font-size: 10px;
}

/* Darker text for lighter backgrounds */
.treemap-rect[fill="#c3ffff"] ~ .treemap-text,
.treemap-rect[fill="#8be2f2"] ~ .treemap-text,
.treemap-rect[fill="#54c3ea"] ~ .treemap-text {
  fill: #333;
}

/* Lighter text for darker backgrounds */
.treemap-rect[fill="#1ca2e0"] ~ .treemap-text,
.treemap-rect[fill="#0291da"] ~ .treemap-text {
  fill: white;
}
/* Tooltip styles */
.tooltip {
  position: absolute;
  background: white;
  padding: 5px;
  border: 1px solid #ccc;
  border-radius: 3px;
  pointer-events: none;
  font-size: 16px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
    /*─────────────────────────────────────────────────────────────────*/
    /* Title bar inside each “card”                                     */
    .map-title {
      height: 32px;
      line-height: 32px;
      font-weight: bold;
      font-size: 15px;
      padding-left: 12px;
      background: #f9f9f9;
      border-bottom: 1px solid #ddd;
      color: #333;
      box-sizing: border-box;
    }

    /*─────────────────────────────────────────────────────────────────*/
    /* Container for map/chart—fills the area under the title bar       */
    .map-inner {
      width: 100%;
      height: calc(100% - 32px);
      position: relative;
    }

    /* If you need a custom pixel‐sized canvas for Plotly, override here */
    .map-inner1 {
      position: absolute;
      left: 0;
      top: 32px; /* below the map-title (32px) */
      width: 100%;
      height: calc(100% - 32px);
    }

    /*─────────────────────────────────────────────────────────────────*/
    /* Hide Mapbox attribution & logo (optional)                        */
    .mapboxgl-ctrl-logo,
    .mapboxgl-ctrl-attrib {
      display: none !important;
    }
  </style>
</head>

<body>
  <!-- 1) SCENARIO dropdown -->
  <select id="scenarioSelector">
    <option value="Scenario 1">Tariffs in effect</option>
    <option value="Scenario 2">Tariffs threatened</option>
  </select>

  <!-- 2) COUNTRY dropdown -->
  <select id="countrySelector">
    <option value="All" selected>All Countries</option>
  </select>

  <!-- 3) SECTOR dropdown -->
  <select id="sectorSelector">
    <option value="All" selected>All Sectors</option>
  </select>

  <!-- Trade Loss Card - Add this after the sectorSelector -->
<div id="tradeLossCard">
  <h4>Total Trade Loss</h4>
  <p id="tradeLossValue">$0</p>
</div>

  <!-- LEFT map box -->
  <div class="map-box left">
    <div class="map-title">USA current imports from ASEAN, 2024</div>
    <div id="map" class="map-inner"></div>
  </div>

  <!-- RIGHT map box -->
  <div class="map-box right">
    <div class="map-title">USA estimated imports from ASEAN (after tariff)</div>
    <div id="map2" class="map-inner"></div>
  </div>

  <!-- NEW: 3D Bar chart UNDER the LEFT map (PRIMARY) -->
  <div class="chart-box left-under">
    <div class="map-title">USA current imports of goods from ASEAN, 2024</div>
    <div id="bar3dChartPrimary" class="map-inner1"></div>
  </div>

  <!-- MOVED: 3D Bar chart UNDER the RIGHT map (ESTIMATED) -->
  <!-- (This was originally under the LEFT map; we simply changed `.left-under` → `.right-under`
       and `left: 2%` → `left: 51%`. Everything else—including height: 75%—is untouched.) -->
  <div class="chart-box right-under">
    <div class="map-title">USA estimated imports of goods from ASEAN (after tariff)</div>
    <div id="bar3dChart" class="map-inner1"></div>
  </div>

  <!-- Dumbbell chart box below both 3D bar charts -->
  <div class="chart-box left-under2">
    <div class="map-title">Simple average actual tariff vs new USA tariff by HS2 Code products</div>
    <div id="dumbbellChart" class="map-inner"></div>
  </div>

<!-- Treemap container - Add this where you want the treemap to appear -->
<div class="chart-box treemap-container">
  <div class="map-title">USA current imports of goods by Sector</div>
  <div id="treemapChartPrimary" class="map-inner"></div>
</div>

<div class="chart-box treemap-container-right">
  <div class="map-title">USA estimated imports of goods by Sector</div>
  <div id="treemapChart" class="map-inner"></div>
</div>

  <!-- Mapbox GL JS -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoiYmhvbGVlIiwiYSI6ImNrN2tibG9pNzAwajMzbWw4ZnlpcDNqY2wifQ.o-qJAmRdkh-McoubI4E2DA';

    // URLs for GeoJSON and CSV
    const GEOJSON_URL = 'https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson';
    const CSV_URL     = 'https://raw.githubusercontent.com/USTariffOnASEAN/USTariffOnASEAN/main/USTARIFF.csv';

    // We'll store parsed rows here so all charts can access them
    let rowsForChart = [];

    // ────────────────────────────────────────────────────────────────────
    // 1) Load GeoJSON + CSV in parallel, then build everything
    // ────────────────────────────────────────────────────────────────────
    Promise.all([
      fetch(GEOJSON_URL).then(r => r.json()),
      fetch(CSV_URL).then(r => r.text())
    ])
    .then(([countriesGeoJSON, csvText]) => {
      processDataAndBuildMap(countriesGeoJSON, csvText);

      // After maps are ready, draw both 3D bars + the dumbbell chart once:
      build3DChartPrimary(rowsForChart);
      build3DChart(rowsForChart);
      buildDumbbellChart(rowsForChart);
  buildTreemapChart(rowsForChart); // Add this line
    buildPrimaryTreemapChart(rowsForChart); // Second treemap (primaryvalue_x)
  updateTradeLossCard(rowsForChart);  // Add this line
    })
    .catch(err => {
      console.error('Error loading data:', err);
      alert('Failed to load GeoJSON or CSV. Check console.');
    });


        function formatValue(val) {
      val = parseFloat(val);
      if (isNaN(val)) return '0';
      if (val >= 1e9) return (val / 1e9).toFixed(2) + 'B';
      if (val >= 1e6) return (val / 1e6).toFixed(2) + 'M';
      if (val >= 1e3) return (val / 1e3).toFixed(1) + 'K';
      return val.toFixed(0);
    }

    // Format numbers into K, M, B - Add with other utility functions
function formatNumber(num) {
  const n = parseFloat(num);
  if (isNaN(n)) return "$0";
  if (n <= -1000000000) return "-$" + (n / -1000000000).toFixed(2) + "B";
  if (n <= -1000000) return "-$" + (n / -1000000).toFixed(2) + "M";
  if (n <= -1000) return "-$" + (n / -1000).toFixed(1) + "K";
  return "$" + n.toFixed(0);
}

// Add this with your other utility functions
let currentTreemapData = null;

function handleTreemapResize() {
  if (currentTreemapData) {
    buildTreemapChart(currentTreemapData);
  }
}


  function createTradeLossCard() {
    const controls = document.getElementById("controls");

    const card = document.createElement("div");
    card.id = "tradeLossCard";
    card.style.background = "white";
    card.style.padding = "15px";
    card.style.borderRadius = "10px";
    card.style.boxShadow = "0 2px 6px rgba(0,0,0,0.1)";
    card.style.display = "inline-block";
    card.style.marginLeft = "auto";

    const title = document.createElement("div");
    title.textContent = "Total Trade Loss";
    title.style.fontWeight = "bold";
    title.style.color = "#555";
    title.style.fontSize = "14px";

    const value = document.createElement("div");
    value.id = "totalLossValue";
    value.textContent = "$0";
    value.style.fontSize = "20px";
    value.style.fontWeight = "bold";
    value.style.color = "#0291da";

    card.appendChild(title);
    card.appendChild(value);
    controls.appendChild(card);
  }
// Update trade loss card - Add with other utility functions
function updateTradeLossCard(rows) {
if (!rows || rows.length === 0) {
        const totalLoss = countryData.reduce((sum, d) => sum + parseFloat(d.Total_trade_loss || 0), 0);
        // CHANGE THIS LINE:
        const formattedVal1 = formatNumber(totalLoss); // <-- Change formatValue to formatNumber
        document.getElementById('totalLossValue').textContent = `${totalLoss}`;
        return;
    }


  // Detect column names
  const sample = rows[0];
  let tradeLossKey = null;
let countryKey = null, sectorKey = null, scenarioKey = null;
  Object.keys(sample).forEach(key => {
    const lc = key.toLowerCase();
    if (lc.includes('total_trade_loss')) tradeLossKey = key;
    if (lc.includes('country')) countryKey = key;
if (lc.includes('sector')) sectorKey = key;
 if (lc.includes('scenario'))  scenarioKey = key;
  });

 if (!tradeLossKey || !countryKey || !sectorKey || !scenarioKey) return;

  const selCountry = getSelectedCountry();
  const selSector = getSelectedSector();
  const selScenario = document.getElementById('scenarioSelector').value;

  const totalLoss = rows.reduce((sum, row) => {
    // Apply filters
    const scenario = String(row[scenarioKey]).trim();
    const country = String(row[countryKey]).trim();
    const sector = String(row[sectorKey]).trim();
    if (selCountry !== 'All' && country !== selCountry) return sum;
    if (selSector !== 'All' && sector !== selSector) return sum;
    
       if (scenario !== selScenario) return sum;
    if (selCountry !== 'All' && country !== selCountry) return sum;
    if (selSector  !== 'All' && sector  !== selSector)  return sum;
    const val = parseFloat(row[tradeLossKey]) || 0;
    return sum + val;
  }, 0);
 const formattedVal1 = formatNumber(totalLoss);
  document.getElementById("tradeLossValue").textContent = formattedVal1;
} 

    // ────────────────────────────────────────────────────────────────────
    // processDataAndBuildMap: same as your original script, unmodified,
    // except that in updateAllFilters() we now call both 3D‐bar builders.
    // ────────────────────────────────────────────────────────────────────
    function processDataAndBuildMap(countriesGeoJSON, csvText) {
      // 2) Parse the CSV with PapaParse
      const parsed = Papa.parse(csvText, {
        header: true,
        skipEmptyLines: true,
        dynamicTyping: true
      });
      const rows = parsed.data;
      rowsForChart = rows; // for build3DChartPrimary, build3DChart, buildDumbbellChart

      // 3) Detect column names used by maps & charts:
      const sampleRow = rows[0] || {};
      const colNames  = Object.keys(sampleRow);
      let isoKey = null, valueKey = null, scenarioKey = null,
          importsKey = null, countryKey = null, sectorKey = null,
          hs2Key = null, minAveKey = null, tariffKey = null;
      colNames.forEach(key => {
        const lc = key.toLowerCase();
        if (lc.includes('iso3'))          isoKey      = key;
        if (lc.includes('primaryvalue'))  valueKey    = key; // primaryValue_x
        if (lc.includes('scenario'))      scenarioKey = key;
        if (lc === 'estimated_imports')   importsKey  = key;
        if (lc.includes('country'))       countryKey  = key;
        if (lc.includes('sector'))        sectorKey   = key;
        if (lc === 'hs2_code')            hs2Key      = key;
        if (lc === 'minave')              minAveKey   = key;
        if (lc === 'new_tariff_new')      tariffKey   = key;
      });
      if (!isoKey || !valueKey || !scenarioKey || !importsKey || !countryKey || !sectorKey || !hs2Key || !minAveKey || !tariffKey) {
        console.warn('Missing one of: ISO3 / primaryValue_x / scenario / estimated_imports / country / sector / HS2_Code / MinAve / new_tariff_new in CSV.');
      }

      // 4) Build sorted sets of unique countries & sectors
      const countrySet = new Set();
      const sectorSet  = new Set();
      rows.forEach(r => {
        const c = r[countryKey]; if (c) countrySet.add(String(c).trim());
        const s = r[sectorKey]; if (s) sectorSet.add(String(s).trim());
      });
      const uniqueCountries = Array.from(countrySet).sort((a,b) => a.localeCompare(b));
      const uniqueSectors   = Array.from(sectorSet).sort((a,b) => a.localeCompare(b));

      // 5) Populate countrySelector
      const countrySelector = document.getElementById('countrySelector');
      uniqueCountries.forEach(cn => {
        const opt = document.createElement('option');
        opt.value = cn;
        opt.text  = cn;
        countrySelector.appendChild(opt);
      });

      // 6) Populate sectorSelector
      const sectorSelector = document.getElementById('sectorSelector');
      uniqueSectors.forEach(sn => {
        const opt = document.createElement('option');
        opt.value = sn;
        opt.text  = sn;
        sectorSelector.appendChild(opt);
      });

      // 7) Prepare aggregation structures for the 3D maps
      let aggregatesValue   = { 'Scenario 1': {}, 'Scenario 2': {} };
      let aggregatesImports = { 'Scenario 1': {}, 'Scenario 2': {} };
      let maxVal1 = 0, maxVal2 = 0, maxImp1 = 0, maxImp2 = 0;

      function recomputeAggregates() {
        aggregatesValue   = { 'Scenario 1': {}, 'Scenario 2': {} };
        aggregatesImports = { 'Scenario 1': {}, 'Scenario 2': {} };
        maxVal1 = maxVal2 = maxImp1 = maxImp2 = 0;

        const selCountry = getSelectedCountry();
        const selSector  = getSelectedSector();

        rows.forEach(r => {
          const rawIso = r[isoKey];
          if (!rawIso) return;

          const rCountry = String(r[countryKey]).trim();
          const rSector  = String(r[sectorKey]).trim();
          // apply country/sector filters
          if (selCountry !== 'All' && rCountry !== selCountry) return;
          if (selSector  !== 'All' && rSector  !== selSector)  return;

          const iso = String(rawIso).trim().toUpperCase();
          const scn = String(r[scenarioKey]).trim();
          if (scn !== 'Scenario 1' && scn !== 'Scenario 2') return;

          // primaryValue_x aggregation
          const vRaw = parseFloat(r[valueKey]);
          const v    = isNaN(vRaw) ? 0 : vRaw;
          aggregatesValue[scn][iso] = (aggregatesValue[scn][iso] || 0) + v;
          if (scn === 'Scenario 1' && aggregatesValue[scn][iso] > maxVal1) maxVal1 = aggregatesValue[scn][iso];
          if (scn === 'Scenario 2' && aggregatesValue[scn][iso] > maxVal2) maxVal2 = aggregatesValue[scn][iso];

          // estimated_imports aggregation
          const iRaw = parseFloat(r[importsKey]);
          const i    = isNaN(iRaw) ? 0 : iRaw;
          aggregatesImports[scn][iso] = (aggregatesImports[scn][iso] || 0) + i;
          if (scn === 'Scenario 1' && aggregatesImports[scn][iso] > maxImp1) maxImp1 = aggregatesImports[scn][iso];
          if (scn === 'Scenario 2' && aggregatesImports[scn][iso] > maxImp2) maxImp2 = aggregatesImports[scn][iso];
        });

        // Write aggregated values back into GeoJSON properties
        countriesGeoJSON.features.forEach(feature => {
          const geoIso = feature.properties['ISO3166-1-Alpha-3']
                         ? feature.properties['ISO3166-1-Alpha-3'].trim().toUpperCase()
                         : null;
          feature.properties.value1   = aggregatesValue['Scenario 1'][geoIso]   || 0;
          feature.properties.value2   = aggregatesValue['Scenario 2'][geoIso]   || 0;
          feature.properties.imports1 = aggregatesImports['Scenario 1'][geoIso] || 0;
          feature.properties.imports2 = aggregatesImports['Scenario 2'][geoIso] || 0;
        });
      }

      // Initial aggregation
      recomputeAggregates();

      // ────────────────────────────────────────────────────────────────────
      // Build Map 1 (left)
      // ────────────────────────────────────────────────────────────────────
      const map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/light-v11',
        center: [122.7289777362036, 8.4608357942721568],
        zoom: 2.6514121880681563,
        pitch: 0,
        bearing: -10,
        projection: 'mercator'
      });

      map.on('load', () => {
        map.addSource('countries-with-values', {
          type: 'geojson',
          data: countriesGeoJSON
        });

        const ASEAN_NAMES = [
          'Brunei','Cambodia','Indonesia','Laos','Malaysia',
          'Myanmar','Philippines','Singapore','Thailand','Viet Nam'
        ];

        map.addLayer({
          id: 'asean-3d-extrusion',
          type: 'fill-extrusion',
          source: 'countries-with-values',
          filter: ['match',['get','name'],ASEAN_NAMES,true,false],
          paint: {
            'fill-extrusion-height': [
              'match',
              ['get','name'],
              'Brunei',    100,
              'Cambodia',  100,
              'Indonesia', 100,
              'Laos',      100,
              'Malaysia',  100,
              'Myanmar',   100,
              'Philippines',100,
              'Singapore', 100,
              'Thailand',  1000,
              'Viet Nam',  100,
              /* default */ 0
            ],
            'fill-extrusion-base': 0,
            // placeholder—overwritten by updateAllFilters()
            'fill-extrusion-color': [
              'interpolate',['linear'],['get','value1'],
              0, '#c3ffff',
              maxVal1/4, '#8be2f2',
              maxVal1/2, '#54c3ea',
              (3*maxVal1)/4, '#1ca2e0',
              maxVal1, '#0291da'
            ],
            'fill-extrusion-opacity': 1
          }
        });

        map.setLight({
          anchor: 'viewport',
          color: 'white',
          intensity: 0.2,
          position: [1.5, 90, 40]
        });

        const popup = new mapboxgl.Popup({
          closeButton: false,
          closeOnClick: false
        });
        map.on('mousemove','asean-3d-extrusion',(e) => {
          map.getCanvas().style.cursor = 'pointer';
          const f  = e.features[0];
          const cn = f.properties.name;
          const sc = document.getElementById('scenarioSelector').value;
          const dispVal = (sc === 'Scenario 1')
                          ? f.properties.value1
                          : f.properties.value2;

        const formattedVal = formatValue(dispVal);
          popup
            .setLngLat(e.lngLat)
            .setHTML(`<strong>${cn}</strong><br><strong>Import value:</strong> $${formattedVal.toLocaleString()}`)
            .addTo(map);
        });
        map.on('mouseleave','asean-3d-extrusion',() => {
          map.getCanvas().style.cursor = '';
          popup.remove();
        });

        // ────────────────────────────────────────────────────────────────────
        // Build Map 2 (right)
        // ────────────────────────────────────────────────────────────────────
        const map2 = new mapboxgl.Map({
          container: 'map2',
          style: 'mapbox://styles/mapbox/light-v11',
                  center: [122.7289777362036, 8.4608357942721568],
        zoom: 2.6514121880681563,
        pitch: 0,
        bearing: -10,
        projection: 'mercator'
        });

        map2.on('load', () => {
          map2.addSource('countries-with-values', {
            type: 'geojson',
            data: countriesGeoJSON
          });

          map2.addLayer({
            id: 'asean-3d-extrusion-2',
            type: 'fill-extrusion',
            source: 'countries-with-values',
            filter: ['match',['get','name'],ASEAN_NAMES,true,false],
            paint: {
              'fill-extrusion-height': [
                'match',
                ['get','name'],
                'Brunei',    100,
                'Cambodia',  100,
                'Indonesia', 100,
                'Laos',      100,
                'Malaysia',  100,
                'Myanmar',   100,
                'Philippines',100,
                'Singapore', 100,
                'Thailand',  100,
                'Viet Nam',  100,
                /* default */ 0
              ],
              'fill-extrusion-base': 0,
              // placeholder—overwritten by updateAllFilters()
              'fill-extrusion-color': [
                'interpolate',['linear'],['get','imports1'],
                0, '#c3ffff',
                maxImp1/4, '#8be2f2',
                maxImp1/2, '#54c3ea',
                (3*maxImp1)/4, '#1ca2e0',
                maxImp1, '#0291da'
              ],
              'fill-extrusion-opacity': 1
            }
          });

          map2.setLight({
            anchor: 'viewport',
            color: 'white',
            intensity: 0.6,
            position: [1.5, 90, 40]
          });

          const popup2 = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false
          });
          map2.on('mousemove','asean-3d-extrusion-2',(e) => {
            map2.getCanvas().style.cursor = 'pointer';
            const f  = e.features[0];
            const cn = f.properties.name;
            const sc = document.getElementById('scenarioSelector').value;
            const dispVal = (sc === 'Scenario 1')
                            ? f.properties.imports1
                            : f.properties.imports2;

                              const formattedVal = formatValue(dispVal);
            popup2
              .setLngLat(e.lngLat)
              .setHTML(`<strong>${cn}</strong><br><strong>Estimated import value:</strong> $${formattedVal.toLocaleString()}`)
              .addTo(map2);
          });
          map2.on('mouseleave','asean-3d-extrusion-2',() => {
            map2.getCanvas().style.cursor = '';
            popup2.remove();
          });

          // ────────────────────────────────────────────────────────────────────
          // updateAllFilters(): Recompute aggregates, update both maps,
          // then redraw **both** 3D bar charts + the dumbbell chart.
          // ────────────────────────────────────────────────────────────────────
          function updateAllFilters() {
            // 1) Recompute aggregates for both maps
            recomputeAggregates();
            // Update trade loss card and treemap
updateTradeLossCard(rowsForChart);
buildTreemapChart(rowsForChart);
  buildPrimaryTreemapChart(rowsForChart);

            // 2) Update GeoJSON data sources
            map.getSource('countries-with-values').setData(countriesGeoJSON);
            map2.getSource('countries-with-values').setData(countriesGeoJSON);

            // 3) Build filter expression (ASEAN + selected country)
            const selCountry = getSelectedCountry();
            const ASEAN_NAMES = [
              'Brunei','Cambodia','Indonesia','Laos','Malaysia',
              'Myanmar','Philippines','Singapore','Thailand','Viet Nam'
            ];
            let countryFilterList;
            if (selCountry === 'All') {
              countryFilterList = ASEAN_NAMES;
            } else {
              countryFilterList = ASEAN_NAMES.includes(selCountry) ? [selCountry] : [];
            }
            const countryFilterExpr = (countryFilterList.length > 0)
              ? ['match',['get','name'],countryFilterList,true,false]
              : ['==',['get','name'],'']; // matches nothing if non-ASEAN chosen

            // 4) Decide which property names to use for coloring
            const sc = document.getElementById('scenarioSelector').value;
            const valueProp  = (sc === 'Scenario 1' ? 'value1'   : 'value2');
            const importProp = (sc === 'Scenario 1' ? 'imports1' : 'imports2');

            // 5) Compute a single min/max across BOTH valueProp & importProp
            const filteredFeatures = countriesGeoJSON.features.filter(f =>
              countryFilterList.includes(f.properties.name)
            );
            let combinedMin = Infinity, combinedMax = -Infinity;
            filteredFeatures.forEach(f => {
              const vRaw = f.properties[valueProp];
              const iRaw = f.properties[importProp];
              if (vRaw < combinedMin) combinedMin = vRaw;
              if (vRaw > combinedMax) combinedMax = vRaw;
              if (iRaw < combinedMin) combinedMin = iRaw;
              if (iRaw > combinedMax) combinedMax = iRaw; 
            });
            if (filteredFeatures.length === 0) {
              combinedMin = 0;
              combinedMax = 1;
            }

            // 6) Update left map’s color ramp
            map.setPaintProperty(
              'asean-3d-extrusion',
              'fill-extrusion-color',
              [
                'interpolate',['linear'],['get', valueProp],
                combinedMin, '#c3ffff',
                combinedMax, '#0291da'
              ]
            );
            map.setFilter('asean-3d-extrusion', countryFilterExpr);

            // 7) Update right map’s color ramp
            map2.setPaintProperty(
              'asean-3d-extrusion-2',
              'fill-extrusion-color',
              [
                'interpolate',['linear'],['get', importProp],
                combinedMin, '#c3ffff',
                combinedMax, '#0291da'
              ]
            );
            map2.setFilter('asean-3d-extrusion-2', countryFilterExpr);

            // 8) Re‐build **both** 3D‐bar charts and the dumbbell chart
            build3DChartPrimary(rowsForChart);
            build3DChart(rowsForChart);
            buildDumbbellChart(rowsForChart);
          }

          // 9) Initial paint & event listeners
          updateAllFilters();
          document.getElementById('scenarioSelector')
                  .addEventListener('change', updateAllFilters);
          document.getElementById('countrySelector')
                  .addEventListener('change', updateAllFilters);
          document.getElementById('sectorSelector')
                  .addEventListener('change', updateAllFilters);
        }); // end map2.on('load')
      }); // end map.on('load')
    }

    // ────────────────────────────────────────────────────────────────────
    // build3DChartPrimary(rows):
    //   This is a **copy** of your original build3DChart(), but:
    //   • It targets container 'bar3dChartPrimary'
    //   • It uses **primaryValue_x** instead of estimated_imports
    // ────────────────────────────────────────────────────────────────────
    function build3DChartPrimary(rows) {
      const containerId = 'bar3dChartPrimary';
      if (!rows || rows.length === 0) {
        Plotly.purge(containerId);
        return;
      }



      // 1) Detect CSV column names (scenario, country, sector, HS2_Code, primaryValue_x)
      const sample = rows[0];
      let scenarioKey = null, countryKey = null, sectorKey = null;
      let hs2Key    = null, primaryKey = null;
      Object.keys(sample).forEach(key => {
        const lc = key.toLowerCase();
        if (lc.includes('scenario'))    scenarioKey = key;
        if (lc.includes('country'))     countryKey  = key;
        if (lc.includes('sector'))      sectorKey   = key;
        if (lc === 'hs2_code')          hs2Key      = key;
        if (lc.includes('primaryvalue'))primaryKey   = key; // primaryValue_x
      });
      if (!scenarioKey || !countryKey || !sectorKey || !hs2Key || !primaryKey) {
        console.warn('Cannot build 3D primary‐value chart: missing one of scenario, country, sector, HS2_Code, or primaryValue_x.');
        Plotly.purge(containerId);
        return;
      }

      // 2) Read current filter selections
      const selScenario = document.getElementById('scenarioSelector').value;
      const selCountry  = document.getElementById('countrySelector').value;
      const selSector   = document.getElementById('sectorSelector').value;

      // 3) Apply filters to “rows”
      const filteredRows = rows.filter(r => {
        const sc = String(r[scenarioKey]).trim();
        const co = String(r[countryKey]).trim();
        const se = String(r[sectorKey]).trim();
        if (sc !== selScenario)    return false;
        if (selCountry !== 'All' && co !== selCountry) return false;
        if (selSector  !== 'All' && se !== selSector)  return false;
        return true;
      });
      if (filteredRows.length === 0) {
        Plotly.purge(containerId);
        return;
      }

      // 4) Identify unique sectors and group HS2 codes
      const sectorMinHS2 = {};
      const uniqueSectors = [...new Set(
        filteredRows.map(d => d[sectorKey])
      )];
      uniqueSectors.forEach(sector => {
        const sectorData = filteredRows.filter(d => d[sectorKey] === sector);
        const hs2Codes = sectorData
                          .map(d => parseInt(d[hs2Key], 10))
                          .filter(x => !isNaN(x));
        sectorMinHS2[sector] = hs2Codes.length ? Math.min(...hs2Codes) : Infinity;
      });
      // Sort sectors by their minimum HS2 code
      const sectors = uniqueSectors.sort((a, b) => sectorMinHS2[a] - sectorMinHS2[b]);

      // For each sector, find distinct HS2 codes (sorted) and compute sum(primaryValue_x)
      const sectorHS2Mapping = {};
      let minPrimary = Infinity, maxPrimary = -Infinity;
      sectors.forEach(sector => {
        const sectorData = filteredRows.filter(d => d[sectorKey] === sector);
        const hs2Set = new Set(
          sectorData
            .map(d => parseInt(d[hs2Key], 10))
            .filter(x => !isNaN(x))
        );
        const hs2CodesInSector = Array.from(hs2Set).sort((a, b) => a - b);
        sectorHS2Mapping[sector] = hs2CodesInSector;

        hs2CodesInSector.forEach(hs2 => {
          const hs2Data = sectorData.filter(d => parseInt(d[hs2Key], 10) === hs2);
          const sumPrimary = hs2Data.reduce((sum, d) => {
            const val = parseFloat(d[primaryKey]);
            return sum + (isNaN(val) ? 0 : val);
          }, 0);
          if (sumPrimary > 0) {
            minPrimary = Math.min(minPrimary, sumPrimary);
            maxPrimary = Math.max(maxPrimary, sumPrimary);
          }
        });
      });
      if (minPrimary === Infinity) minPrimary = 0;
      if (maxPrimary === -Infinity) maxPrimary = 1;

      // 5) Prepare cube traces for Plotly
      const traces = [];
      const SECTOR_SPACING = 4; // adjustable spacing between sectors
      const categoryLetters = [];
      let maxCategoriesPerSector = 0;
      Object.values(sectorHS2Mapping).forEach(arr => {
        maxCategoriesPerSector = Math.max(maxCategoriesPerSector, arr.length);
      });
      for (let i = 0; i < maxCategoriesPerSector; i++) {
        categoryLetters.push(String.fromCharCode(65 + i));
      }

      sectors.forEach((sector, xIndex) => {
        const adjustedXIndex = xIndex * SECTOR_SPACING;
        const hs2Codes = sectorHS2Mapping[sector];

        hs2Codes.forEach((hs2, catIndex) => {
          const sectorData = filteredRows.filter(d => parseInt(d[hs2Key], 10) === hs2);
          const sumPrimary = sectorData.reduce((sum, d) => {
            const val = parseFloat(d[primaryKey]);
            return sum + (isNaN(val) ? 0 : val);
          }, 0);
          if (sumPrimary <= 0) return;

          // Build one cube for this (sector, HS2) combination
          const cubeSize = 0.4; // adjustable cube edge length
          const x0 = adjustedXIndex - cubeSize, x1 = adjustedXIndex + cubeSize;
          const y0 = catIndex - cubeSize,        y1 = catIndex + cubeSize;
          const z0 = 0,                           z1 = sumPrimary;

          // gradient color from green → purple (for example)
          const norm = (sumPrimary - minPrimary) / (maxPrimary - minPrimary);
          const hue = 120 - (norm * 120); // 120 (green) → 0 (red)
          const color = `hsl(${hue},70%,60%)`;

          const hovertext =
            `Sector: ${sector}<br>` +
            `HS2: ${hs2}<br>` +
            `Primary: ${sumPrimary.toLocaleString()}`;

          traces.push({
            type: 'mesh3d',
            x: [x0, x1, x1, x0, x0, x1, x1, x0],
            y: [y0, y0, y1, y1, y0, y0, y1, y1],
            z: [z0, z0, z0, z0, z1, z1, z1, z1],
            i: [7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2],
            j: [3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3],
            k: [0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6],
            color: color,
            opacity: 1,
            hoverinfo: 'text',
            text: [hovertext],
            flatshading: true,
            showscale: false
          });
        });
      });

      // 6) Build layout for Plotly scene
      const layout = {
        scene: {
          xaxis: {
            title: 'Sector',
            tickvals: sectors.map((_, i) => i * SECTOR_SPACING),
            ticktext: sectors,
            tickfont: { size: 10 },
            titlefont: { size: 14 },
            range: [
              0 - SECTOR_SPACING * 0.1,
              (sectors.length - 1) * SECTOR_SPACING + SECTOR_SPACING * 0.1
            ]
          },
          yaxis: {
            title: '',
            tickvals: categoryLetters.map((_, i) => i),
            ticktext: categoryLetters,
            tickfont: { size: 10 },
            titlefont: { size: 14 },
             showticklabels: false
          },
          zaxis: {
            title: 'Import value (USD)',
            tickformat: '$,.1s',
            tickfont: { size: 10 },
            titlefont: { size: 14 },
            range: [0, maxPrimary * 1.1]
          },
          aspectmode: 'manual',
          aspectratio: {
            x: 1.5,
            y: maxCategoriesPerSector / (sectors.length || 1),
            z: 0.7
          },
          camera: {
            eye: { x: 1.5, y: 1.5, z: 1.0 }
          }
        },
        margin: { l: 0, r: 0, b: 0, t: 10, pad: 50 },
        hovermode: 'x'
      };

      // 7) Render with Plotly
      Plotly.newPlot(containerId, traces, layout, { responsive: true });
    }

    // ────────────────────────────────────────────────────────────────────
    // build3DChart(rows):
    //   This is your original function for “Estimated Imports”.
    //   It still renders into “bar3dChart”.  We did NOT touch its contents,
    //   except to leave it under the new container “.right-under”.
    // ────────────────────────────────────────────────────────────────────
    function build3DChart(rows) {
      const containerId = 'bar3dChart';
      if (!rows || rows.length === 0) {
        Plotly.purge(containerId);
        return;
      }

      // 1) Detect relevant column names from CSV:
      const sample = rows[0];
      let scenarioKey = null, countryKey = null, sectorKey = null;
      let hs2Key = null, importsKey = null;
      Object.keys(sample).forEach(key => {
        const lc = key.toLowerCase();
        if (lc.includes('scenario'))     scenarioKey = key;
        if (lc.includes('country'))      countryKey  = key;
        if (lc.includes('sector'))       sectorKey   = key;
        if (lc === 'hs2_code')           hs2Key      = key;
        if (lc === 'estimated_imports')  importsKey  = key;
      });
      if (!scenarioKey || !countryKey || !sectorKey || !hs2Key || !importsKey) {
        console.warn('Cannot build 3D estimated‐imports chart: missing one of scenario, country, sector, HS2_Code, or estimated_imports.');
        Plotly.purge(containerId);
        return;
      }

      // 2) Read current filter selections
      const selScenario = document.getElementById('scenarioSelector').value;
      const selCountry  = document.getElementById('countrySelector').value;
      const selSector   = document.getElementById('sectorSelector').value;

      // 3) Apply filters to “rows”
      const filteredRows = rows.filter(r => {
        const sc = String(r[scenarioKey]).trim();
        const co = String(r[countryKey]).trim();
        const se = String(r[sectorKey]).trim();
        if (sc !== selScenario)    return false;
        if (selCountry !== 'All' && co !== selCountry) return false;
        if (selSector  !== 'All' && se !== selSector)  return false;
        return true;
      });
      if (filteredRows.length === 0) {
        Plotly.purge(containerId);
        return;
      }

      // 4) Identify unique sectors and group HS2 codes
      const sectorMinHS2 = {};
      const uniqueSectors = [...new Set(
        filteredRows.map(d => d[sectorKey])
      )];
      uniqueSectors.forEach(sector => {
        const sectorData = filteredRows.filter(d => d[sectorKey] === sector);
        const hs2Codes = sectorData
                          .map(d => parseInt(d[hs2Key], 10))
                          .filter(x => !isNaN(x));
        sectorMinHS2[sector] = hs2Codes.length ? Math.min(...hs2Codes) : Infinity;
      });
      // Sort sectors by their minimum HS2 code
      const sectors = uniqueSectors.sort((a, b) => sectorMinHS2[a] - sectorMinHS2[b]);

      // For each sector, find distinct HS2 codes (sorted) and compute sum(estimated_imports)
      const sectorHS2Mapping = {};
      let minImport = Infinity, maxImport = -Infinity;
      sectors.forEach(sector => {
        const sectorData = filteredRows.filter(d => d[sectorKey] === sector);
        const hs2Set = new Set(
          sectorData
            .map(d => parseInt(d[hs2Key], 10))
            .filter(x => !isNaN(x))
        );
        const hs2CodesInSector = Array.from(hs2Set).sort((a, b) => a - b);
        sectorHS2Mapping[sector] = hs2CodesInSector;

        hs2CodesInSector.forEach(hs2 => {
          const hs2Data = sectorData.filter(d => parseInt(d[hs2Key], 10) === hs2);
          const sumImport = hs2Data.reduce((sum, d) => {
            const val = parseFloat(d[importsKey]);
            return sum + (isNaN(val) ? 0 : val);
          }, 0);
          if (sumImport > 0) {
            minImport = Math.min(minImport, sumImport);
            maxImport = Math.max(maxImport, sumImport);
          }
        });
      });
      if (minImport === Infinity) minImport = 0;
      if (maxImport === -Infinity) maxImport = 1;

      // 5) Prepare cube traces for Plotly
      const traces = [];
      const SECTOR_SPACING = 4; // adjustable spacing between sectors
      const categoryLetters = [];
      let maxCategoriesPerSector = 0;
      Object.values(sectorHS2Mapping).forEach(arr => {
        maxCategoriesPerSector = Math.max(maxCategoriesPerSector, arr.length);
      });
      for (let i = 0; i < maxCategoriesPerSector; i++) {
        categoryLetters.push(String.fromCharCode(65 + i));
      }

      sectors.forEach((sector, xIndex) => {
        const adjustedXIndex = xIndex * SECTOR_SPACING;
        const hs2Codes = sectorHS2Mapping[sector];

        hs2Codes.forEach((hs2, catIndex) => {
          const sectorData = filteredRows.filter(d => parseInt(d[hs2Key], 10) === hs2);
          const sumImport = sectorData.reduce((sum, d) => {
            const val = parseFloat(d[importsKey]);
            return sum + (isNaN(val) ? 0 : val);
          }, 0);
          if (sumImport <= 0) return;

          // Build one cube for this (sector, HS2) combination
          const cubeSize = 0.4; // adjustable cube edge length
          const x0 = adjustedXIndex - cubeSize, x1 = adjustedXIndex + cubeSize;
          const y0 = catIndex - cubeSize,        y1 = catIndex + cubeSize;
          const z0 = 0,                           z1 = sumImport;

          // gradient color from blue → red
          const norm = (sumImport - minImport) / (maxImport - minImport);
          const hue = 240 - (norm * 180); // 240 (blue) → 60 (red)
          const color = `hsl(${hue},70%,60%)`;

          const hovertext =
            `Sector: ${sector}<br>` +
            `HS2: ${hs2}<br>` +
            `Import: $${sumImport.toLocaleString()}`;

          traces.push({
            type: 'mesh3d',
            x: [x0, x1, x1, x0, x0, x1, x1, x0],
            y: [y0, y0, y1, y1, y0, y0, y1, y1],
            z: [z0, z0, z0, z0, z1, z1, z1, z1],
            i: [7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2],
            j: [3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3],
            k: [0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6],
            color: color,
            opacity: 1,
            hoverinfo: 'text',
            text: [hovertext],
            flatshading: false,
            showscale: false
          });
        });
      });

      // 6) Build layout for Plotly scene
      const layout = {
        scene: {
          xaxis: {
            title: 'Sector',
            tickvals: sectors.map((_, i) => i * SECTOR_SPACING),
            ticktext: sectors,
            tickfont: { size: 10 },
            titlefont: { size: 14 },
            range: [
              0 - SECTOR_SPACING * 0.1,
              (sectors.length - 1) * SECTOR_SPACING + SECTOR_SPACING * 0.1
            ]
          },
          yaxis: {
            title: '',
            tickvals: categoryLetters.map((_, i) => i),
            ticktext: categoryLetters,
            tickfont: { size: 10 },
            titlefont: { size: 14 },
             showticklabels: false
          },
          zaxis: {
            title: 'Estimated imports (USD)',
            tickformat: '$,.1s',
            tickfont: { size: 10 },
            titlefont: { size: 14 },
            range: [0, maxImport * 1.1]
          },
          aspectmode: 'manual',
          aspectratio: {
            x: 1.5,
            y: maxCategoriesPerSector / (sectors.length || 1),
            z: 0.7
          },
          camera: {
            eye: { x: 1.5, y: 1.5, z: 1.0 }
          }
        },
        margin: { l: 0, r: 0, b: 0, t: 40, pad: 0 },
        hovermode: 'x'
      };

      // 7) Render with Plotly
      Plotly.newPlot(containerId, traces, layout, { responsive: true });
    }

    // ────────────────────────────────────────────────────────────────────
    // buildDumbbellChart(rows):
    //   EXACT same code as your original script, unchanged.
    // ────────────────────────────────────────────────────────────────────
    function buildDumbbellChart(rows) {
      const containerId = 'dumbbellChart';
      if (!rows || rows.length === 0) {
        Highcharts.chart(containerId, { series: [] });
        return;
      }

      // 1) Detect relevant column names inside the CSV’s header:
      const sample = rows[0];
      let scenarioKey = null, countryKey = null, sectorKey = null;
      let hs2Key = null, minAveKey = null, tariffKey = null;
      Object.keys(sample).forEach(key => {
        const lc = key.toLowerCase();
        if (lc.includes('scenario'))     scenarioKey = key;
        if (lc.includes('country'))      countryKey  = key;
        if (lc.includes('sector'))       sectorKey   = key;
        if (lc === 'hs2_code')           hs2Key      = key;
        if (lc === 'minave')             minAveKey   = key;
        if (lc === 'new_tariff_new')     tariffKey   = key;
      });
      if (!scenarioKey || !countryKey || !sectorKey || !hs2Key || !minAveKey || !tariffKey) {
        console.warn('Cannot build dumbbell chart: missing one of scenario, country, sector, HS2_Code, MinAve, or new_tariff_new.');
        Highcharts.chart(containerId, { series: [] });
        return;
      }

      // 2) Read current filter selections
      const selScenario = document.getElementById('scenarioSelector').value;
      const selCountry  = document.getElementById('countrySelector').value;
      const selSector   = document.getElementById('sectorSelector').value;

      // 3) Apply filters to “rows”
      const filteredRows = rows.filter(r => {
        const sc = String(r[scenarioKey]).trim();
        const co = String(r[countryKey]).trim();
        const se = String(r[sectorKey]).trim();
        if (sc !== selScenario) return false;
        if (selCountry !== 'All' && co !== selCountry) return false;
        if (selSector  !== 'All' && se !== selSector)  return false;
        return true;
      });
      if (filteredRows.length === 0) {
        Highcharts.chart(containerId, { series: [] });
        return;
      }

      // 4) Group the filtered rows by HS2_Code, summing MinAve & tariff, counting entries
      const grouping = {};
      filteredRows.forEach(r => {
        const h2 = r[hs2Key];
        if (h2 == null) return;
        const key = String(h2).trim();
        if (!grouping[key]) grouping[key] = { sumMin: 0, sumTariff: 0, count: 0 };

        const m = parseFloat(r[minAveKey]);
        const t = parseFloat(r[tariffKey]);
        if (!isNaN(m)) grouping[key].sumMin += m;
        if (!isNaN(t)) grouping[key].sumTariff += t;
        grouping[key].count += 1;
      });

      // 5) Build a sorted list of HS2 categories and a matching data array
      const rawCategories  = Object.keys(grouping)
                               .sort((a, b) => {
                                 const na = parseInt(a, 10), nb = parseInt(b, 10);
                                 if (!isNaN(na) && !isNaN(nb)) return na - nb;
                                 return a.localeCompare(b);
                               });
							   
		// Now zero-pad any single‐digit codes:
  const categories = rawCategories.map(cat => cat.padStart(2, '0'));
  
  // 6) Build a matching array of average values for each category
    const data = categories.map((catLabel, i) => {
      // We need the original (un‐padded) key to look up sums:
      const rawKey = rawCategories[i];  
      const obj    = grouping[rawKey];
      const avgMin    = (obj.sumMin    / obj.count) * 100; // decimal→percent
      const avgTariff = (obj.sumTariff / obj.count) * 100;
      return { x: i, low: avgMin, high: avgTariff };
    });

   /*   const data = categories.map((cat, i) => {
        const obj = grouping[cat];
        // Convert decimal → percentage by multiplying by 100:
        const avgMin    = (obj.sumMin    / obj.count) * 100;
        const avgTariff = (obj.sumTariff / obj.count) * 100;
        return { x: i, low: avgMin, high: avgTariff };
      });*/

      // 6) Render (or re-render) Highcharts into #dumbbellChart
      Highcharts.chart(containerId, {
        chart: {
          type: 'dumbbell',
          inverted: false,
          marginTop: 30
        },
        title: { text: null },
        xAxis: {
          categories: categories,
          title: { text: 'HS2 Code' },
          labels: {
            rotation: -45,
            style: { fontSize: '12px' }
          }
        },
        yAxis: {
          title: { text: 'Simple average tariff (%)' },
          labels: {
            formatter: function() {
              return Math.round(this.value) + '%';
            }
          }
        },
        tooltip: {
          shared: true,
          headerFormat: '<b>HS2 Code: {point.category}</b><br/>',
          pointFormat: '<span style="color:{series.color}">\u25CF</span> {series.name}: <b>{point.y:.0f}%</b><br/>'
        },
        plotOptions: {
          series: {
            dataLabels: {
              enabled: true,
              formatter: function() {
                return Math.round(this.y) + '%';
              }
            }
          }
        },
        series: [
          {
            name: 'Actual Tariff',
            type: 'scatter',
            data: data.map(pt => ({ x: pt.x, y: pt.low })),
            color: '#1f77b4',
            marker: {
              symbol: 'circle',
              fillColor: '#1f77b4',
              lineColor: '#1f77b4',
              radius: 5
            }
          },
          {
            name: 'New Tariff',
            type: 'scatter',
            data: data.map(pt => ({ x: pt.x, y: pt.high })),
            color: '#d62728',
            marker: {
              symbol: 'circle',
              fillColor: '#d62728',
              lineColor: '#d62728',
              radius: 5
            }
          },
          {
            name: '',
            type: 'dumbbell',
            data: data.slice(), 
            color: '#999999',
            connector: {
              width: 1,
              color: '#999999'
            },
            marker: {
              enabled: false
            },
            showInLegend: false,
            enableMouseTracking: false
          }
        ],
        legend: {
          align: 'center',
          verticalAlign: 'top',
          layout: 'horizontal'
        },
        credits: { enabled: false }
      });
    }

 // Replace the existing buildTreemapChart function with this:
function buildTreemapChart(rows) {
  const container = document.getElementById("treemapChart");
  container.innerHTML = ""; // Clear previous chart

  const width = container.clientWidth;
  const height = container.clientHeight;

  if (!rows || rows.length === 0 || width === 0 || height === 0) return;


  // Detect column names
  const sample = rows[0];
  let countryKey = null, sectorKey = null, importsKey = null, scenarioKey = null;
  Object.keys(sample).forEach(key => {
    const lc = key.toLowerCase();
    if (lc.includes('country')) countryKey = key;
    if (lc.includes('sector')) sectorKey = key;
    if (lc === 'estimated_imports') importsKey = key;
  if (lc.includes('scenario'))        scenarioKey = key;
  });

  if (!countryKey || !sectorKey || !importsKey || !scenarioKey) {
    console.warn('Cannot build treemap: missing required columns');
    return;
  }

  // Get current filters
  const selCountry = getSelectedCountry();
  const selSector = getSelectedSector();
const selScenario = document.getElementById('scenarioSelector').value;

  // Filter rows
  const filteredRows = rows.filter(r => {
  const sc = String(r[scenarioKey]).trim();
    const co = String(r[countryKey]).trim();
    const se = String(r[sectorKey]).trim();
  if (sc !== selScenario) return false;
    if (selCountry !== 'All' && co !== selCountry) return false;
    if (selSector !== 'All' && se !== selSector) return false;
    return true;
  });

  // Group by sector
  const sectorData = {};
  filteredRows.forEach(d => {
    const sector = d[sectorKey];
    const val = parseFloat(d[importsKey]) || 0;
    if (!sectorData[sector]) sectorData[sector] = 0;
    sectorData[sector] += val;
  });

  // Convert to hierarchy format
  const root = {
    name: "root",
    children: Object.entries(sectorData).map(([name, value]) => ({
      name,
      value
    }))
  };

  if (root.children.length === 0) return;


  // Format function for M/K
  const format = d3.format(",.1f");
  function formatValue(value) {
    if (value >= 1000000000) return `${format(value/1000000000)}B`;
    if (value >= 1000000) return `${format(value/1000000)}M`;
    if (value >= 1000) return `${format(value/1000)}K`;
    return format(value);
  }


  // Create treemap layout
  const treemap = d3.treemap()
    .size([width, height - 10])
   .paddingOuter(3)  // Space between different sectors
  //.paddingTop(20)   // Extra space at top for labels
  .paddingInner(1)  // Space between sub-sectors (not used here)

    .round(true);

  // Create hierarchy and compute layout
  const hierarchy = d3.hierarchy(root)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);

  treemap(hierarchy);

  // Create SVG
  const svg = d3.select("#treemapChart")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  // Create cells
  const cell = svg.selectAll("g")
    .data(hierarchy.leaves())
    .enter().append("g")
    .attr("transform", d => `translate(${d.x0},${d.y0})`);

  // Add rectangles
  cell.append("rect")
    .attr("class", "treemap-rect")
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .attr("fill", d => {
      // Color scale based on value
      const maxVal = d3.max(hierarchy.leaves(), d => d.value);
      const color = d3.scaleLinear()
        .domain([0, maxVal])
        .range(["#c3ffff", "#0291da"]);
      return color(d.value);
    })
    .on("mouseover", function(event, d) {
      // Show tooltip
      const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("position", "absolute")
        .style("background", "white")
        .style("padding", "5px")
        .style("border", "1px solid #ccc")
        .style("border-radius", "3px")
        .html(`<strong>${d.data.name}</strong><br>Value: $${formatValue(d.value)}`);
      
      tooltip.style("left", `${event.pageX + 5}px`)
             .style("top", `${event.pageY + 5}px`);
    })
    .on("mouseout", function() {
      d3.select(".tooltip").remove();
    });

  // Add text labels
cell.append("text")
  .attr("class", "treemap-text")
  .attr("x", d => (d.x1 - d.x0) / 2)
  .attr("y", d => (d.y1 - d.y0) / 2)
  .attr("dy", "0.35em")
  .each(function(d) {
    const boxWidth = d.x1 - d.x0;
    const boxHeight = d.y1 - d.y0;
    const name = d.data.name;
    const value = ` $${formatValue(d.value)}`;
    
    // Only show labels if there's enough space
    if (boxWidth > 80 && boxHeight > 30) {
      const text = d3.select(this);
      
      // For medium-sized boxes, show two lines
      if (boxWidth > 120 && boxHeight > 40) {
        text.append("tspan")
          .text(name);
          
        text.append("tspan")
          .text(value);
      } 
      // For smaller boxes, just show the value
      else {
        text.text(value);
      }
    }
  });
}

   // code for second treemap
function buildPrimaryTreemapChart(rows) {
  const container = document.getElementById("treemapChartPrimary");
  container.innerHTML = "";

  if (!rows || rows.length === 0) return;

  // Detect column names
  const sample = rows[0];
  let countryKey = null, sectorKey = null, primaryKey = null, scenarioKey = null;
  Object.keys(sample).forEach(key => {
    const lc = key.toLowerCase();
    if (lc.includes('country')) countryKey = key;
    if (lc.includes('sector')) sectorKey = key;
    if (lc.includes('primaryvalue')) primaryKey = key;
  if (lc.includes('scenario'))   scenarioKey = key;
  });

  if (!countryKey || !sectorKey || !primaryKey || !scenarioKey) {
    console.warn('Cannot build primary treemap: missing required columns');
    return;
  }

  // Get current filters
  const selCountry = getSelectedCountry();
  const selSector = getSelectedSector();
const selScenario = document.getElementById('scenarioSelector').value;

  // Filter rows
  const filteredRows = rows.filter(r => {
  const sc = String(r[scenarioKey]).trim();
    const co = String(r[countryKey]).trim();
    const se = String(r[sectorKey]).trim();
  if (sc !== selScenario) return false;
    if (selCountry !== 'All' && co !== selCountry) return false;
    if (selSector !== 'All' && se !== selSector) return false;
    return true;
  });

  // Group by sector
  const sectorData = {};
  filteredRows.forEach(d => {
    const sector = d[sectorKey];
    const val = parseFloat(d[primaryKey]) || 0;
    if (!sectorData[sector]) sectorData[sector] = 0;
    sectorData[sector] += val;
  });

  // Convert to hierarchy format
  const root = {
    name: "root",
    children: Object.entries(sectorData).map(([name, value]) => ({
      name,
      value
    }))
  };

  if (root.children.length === 0) return;

  // Set up dimensions
  const width = container.clientWidth;
  const height = container.clientHeight;

  // Create treemap layout
  const treemap = d3.treemap()
    .size([width, height])
    .padding(1)
    .round(true);

  const hierarchy = d3.hierarchy(root)
    .sum(d => d.value)
    .sort((a, b) => b.value - a.value);

  treemap(hierarchy);

  // Create SVG
  const svg = d3.select("#treemapChartPrimary")
    .append("svg")
    .attr("width", width)
    .attr("height", height);

  // Create cells
  const cell = svg.selectAll("g")
    .data(hierarchy.leaves())
    .enter().append("g")
    .attr("transform", d => `translate(${d.x0},${d.y0})`);

  // Add rectangles
  cell.append("rect")
    .attr("class", "treemap-rect")
    .attr("width", d => d.x1 - d.x0)
    .attr("height", d => d.y1 - d.y0)
    .attr("fill", d => {
      const maxVal = d3.max(hierarchy.leaves(), d => d.value);
      const color = d3.scaleLinear()
        .domain([0, maxVal])
        .range(["#c3ffff", "#0291da"]);
      return color(d.value);
    })
   .on("mouseover", function(event, d) {
      // Show tooltip
      const tooltip = d3.select("body").append("div")
        .attr("class", "treemap-tooltip")
        .style("position", "absolute")
        .style("background", "white")
        .style("padding", "5px")
        .style("border", "1px solid #ccc")
        .style("border-radius", "3px")
        .html(`<strong>${d.data.name}</strong><br>Value: $${formatValue(d.value)}`);
      
      tooltip.style("left", `${event.pageX + 5}px`)
             .style("top", `${event.pageY + 5}px`);
    })
 .on("mousemove", function(event) {
    const tooltip = d3.select(".treemap-tooltip");
    positionTooltip(tooltip, event);
  })
  .on("mouseout", function() {
    d3.select(".treemap-tooltip").remove();
  });


  // Add text labels (same logic as before)
 
  // Add text labels
cell.append("text")
  .attr("class", "treemap-text")
  .attr("x", d => (d.x1 - d.x0) / 2)
  .attr("y", d => (d.y1 - d.y0) / 2)
  .attr("dy", "0.35em")
  .each(function(d) {
    const boxWidth = d.x1 - d.x0;
    const boxHeight = d.y1 - d.y0;
    const name = d.data.name;
    const value = ` $${formatValue(d.value)}`;
    
    // Only show labels if there's enough space
    if (boxWidth > 80 && boxHeight > 30) {
      const text = d3.select(this);
      
      // For medium-sized boxes, show two lines
      if (boxWidth > 120 && boxHeight > 40) {
        text.append("tspan")
          .text(name);
          
        text.append("tspan")
          .text(value);
      } 
      // For smaller boxes, just show the value
      else {
        text.text(value);
      }
    }
  });
}

    // ────────────────────────────────────────────────────────────────────
    // Helper functions to read current dropdown values
    function getSelectedCountry() {
      const val = document.getElementById('countrySelector').value;
      return val ? val : 'All';
    }
    function getSelectedSector() {
      const val = document.getElementById('sectorSelector').value;
      return val ? val : 'All';
    }
  </script>
</body>
</html>
